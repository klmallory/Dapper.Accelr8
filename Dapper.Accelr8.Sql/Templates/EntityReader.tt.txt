<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.DataSetExtensions" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ output extension=".txt" #>
<#@ include file="Includes\\Accelr8or.tt.txt" #>
<#@ include file="Includes\\DbHelper.tt.txt" #>
<#@ include file="Includes\\Manager.tt.txt" #>
<#@ include file="Schema.tt.txt" #>

<#
	var className = @"";
	var idType = @"";
	var entityType = @"";
	var idField = @"";

	var fieldCt = 0;

	var tables = SchemaHelper.GetTables();

	var manager = Manager.Create(Host, GenerationEnvironment);

	// Generate EntityReaders
	foreach (var t in tables)
	{
		var table = t.Value;

		if (table.Ignore)
			continue;

		Debug.WriteLine("Starting EntityReader for Table {0} ", t.Key);

		var name = table.ClassName;

		className = name + "Reader";

		idType = table.CSharpIdType;
		idField = table.IdField;

		entityType = name;

		manager.StartNewFile(Path.Combine(SchemaHelper.ReadersDirectory, name + "Reader.cs")); #>

using System;
using System.Collections.Generic;
using System.Data;
using System.Dynamic;
using System.Linq;
using System.Text;

using <#= SchemaHelper.DAONamespace #>;
using <#= SchemaHelper.TableInfoNamespace #>;
using Dapper;
using Dapper.Accelr8.Sql;
using Dapper.Accelr8.Domain;
using Dapper.Accelr8.Repo;
using Dapper.Accelr8.Repo.Parameters;
using Dapper.Accelr8.Repo.Contracts;

namespace <#= SchemaHelper.ReadersNamespace #>
{
    public class <#= className #> : EntityReader<<#= idType #>, <#= entityType #>>
    {
        public <#= className #>(
            <#= entityType #>TableInfo tableInfo
            , string connectionStringName
            , DapperExecuter executer
            , QueryBuilder queryBuilder
            , JoinBuilder joinBuilder
            , ILoc8 loc8r) 
            : base(tableInfo, connectionStringName, executer, queryBuilder, joinBuilder, loc8r)
        {
			if (s_loc8r == null)
				s_loc8r = loc8r;		 
		}

		static ILoc8 s_loc8r = null;

		//Child Count <#= table.Children.Count() #>
		//Parent Count <#= table.Parents.Count() #>
		<# foreach (var child in table.Children.Where(c => !c.Ignore).GroupBy(c => c.ChildClassName).Select(s => s.First()))
			{ 
				//
				//Add Methods to Resolve Other Children Readers
				//
				var cidType = child.CSharpIdType;
				var ceType = child.ChildClassName; 
				var readerName = "_" + Accelr8or.Inflector.MakeInitialLowerCase(ceType) + "Reader"; 

				if (cidType != "CompoundKey" && child.Columns.Count(c => c.ChildColumnIsPrimaryKey) > 1)
					throw new Exception("Crazy");
#>
		//Is CompoundKey <#= child.UseCompoundKey #>
		protected static IEntityReader<<#= cidType #> , <#= ceType #>> Get<#= ceType #>Reader()
		{
			return s_loc8r.GetReader<<#= cidType #> , <#= ceType #>>();
		}

		<# } #>

	<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
	{ 
		//
		//Add Methods to Set Children collections on the parents and set circular references.
		//

		var cidType = child.CSharpIdType;
		var ceType = child.ChildClassName; 
	#>	/// <summary>
		/// Sets the children of type <#= ceType #> on the parent on <#= Accelr8or.Inflector.MakePlural(ceType) #>.
		/// From foriegn key <#= child.Name #>
		/// </summary>
		/// <param name="results"></param>
		/// <param name="children"></param>
		public void SetChildren<#= child.ChildClassFieldName #>(IList<<#= entityType #>> results, IList<object> children)
		{
			//Child Id Type: <#= cidType #>
			//Child Type: <#= ceType #>

			if (results == null || results.Count < 1 || children == null || children.Count < 1)
				return;

			var typedChildren = children.OfType<<#= child.ChildClassName #>>();

			foreach (var r in results)
			{
				if (r == null)
					continue;
				r.Loaded = false;
				

				r.<#= child.ChildClassFieldName #> = typedChildren.Where(b => <# for(var i = 0; i < child.Columns.Count; i++) { if ( i > 0 ) { #> && <# } #> b.<#= child.Columns[i].ChildColumnFieldName #> == r.<#= child.Columns[i].ParentColumnFieldName #> <# } #>).ToList();
				r.<#= child.ChildClassFieldName #>.ToList().ForEach(b => { b.Loaded = false; b.<#= child.ParentClassFieldName #> = r; b.Loaded = true; });
				
				r.Loaded = true;
			}
		}

	<# } #>
		/// <summary>
		/// Loads the table <#= table.TableName #> into class <#= entityType #>
		/// </summary>
		/// <param name="results"><#= entityType #></param>
		/// <param name="row"></param>
        public override <#= entityType #> LoadEntity(dynamic row)
        {
            var dataRow = (IDictionary<string, object>)row;
            var domain = new <#= entityType #>();
			domain.Loaded = false;

	<# foreach (var col in table.Columns.Where(c => !c.Ignore))
	{ var castFormat = Accelr8or.GetCastForType(col); #>
		domain.<#= col.ColumnFieldName #> = <#= string.Format(castFormat, @"GetRowData<" + Accelr8or.GetNullableType(col.IsNullable, col.CSharpType) + ">(dataRow, \"" + col.ColumnName + "\")") #>; 
      <# } #>
			<# if (table.UseCompoundKey) { #>
	domain.<#= SchemaHelper.defaultIdField #> = <#= entityType #>.GetCompoundKeyFor(domain); <# } #>

			domain.IsDirty = false;
			domain.Loaded = true;
			return domain;
		}

		/// <summary>
		/// Add All the children to the query for the specified <#= idType #> Id.
		/// </summary>
		/// <param name="results">IEntityReader<<#= idType #>, <#= entityType #>></param>
		/// <param name="id"><#= idType #></param>
        public override IEntityReader<<#= idType #>, <#= entityType #>> WithAllChildrenForExisting(<#= entityType #> existing)
        {
			<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
			{  var ceType = child.ChildClassName; #>
			WithChildForParentValues(Get<#= ceType #>Reader()
				, new object[] { <# foreach (var kc in child.Columns) {#> existing.<#= kc.ParentColumnFieldName #>, <# } #> } 
				, new string[] { <# foreach (var kc in child.Columns) {#> "<#= kc.ChildColumnFieldName #>", <# } #> }
				, SetChildren<#= child.ChildClassFieldName #>);
			<# } #>

            return this;
        }


        public override void SetAllChildrenForExisting(<#= entityType #> entity)
        {
			<# if (table.Children != null && table.Children.Count > 0) { 
#>ClearAllQueries();

            if (entity == null)
                return;

			<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
			{  var ceType = child.ChildClassName; #>
			WithChildForParentValues(Get<#= ceType #>Reader()
				, new object[] { <# foreach (var kc in child.Columns) {#> entity.<#= kc.ParentColumnFieldName #>, <# } #> } 
				, new string[] { <# foreach (var kc in child.Columns) {#> "<#= kc.ChildColumnFieldName #>", <# } #> }
				, SetChildren<#= child.ChildClassFieldName #>);

			<# } #>

QueryResultForChildrenOnly(new List<<#= entityType #>>() { entity });
			entity.Loaded = false;
			<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
			{ 
				if (child.Ignore)
					continue;

			var cidType = child.CSharpIdType;
			var ceType = child.ChildClassName; 
#>Get<#= ceType #>Reader().SetAllChildrenForExisting(entity.<#= Accelr8or.Inflector.MakePlural(ceType) #>);
			<# } }#>	
			entity.Loaded = true;
		}

		public override void SetAllChildrenForExisting(IList<<#= entityType #>> entities)
        {
			<# if (table.Children != null && table.Children.Count > 0) { 
#>ClearAllQueries();

            if (entities == null || entities.Count < 1)
                return;

			entities = entities.Where(e => e != null).ToList();

            if (entities.Count < 1)
                return;

			<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
			{ 
			var ceType = child.ChildClassName; 

#>WithChildForParentsValues(Get<#= ceType #>Reader()
				, entities.Select(s => new object[] { <# foreach (var kc in child.Columns) {#> s.<#= kc.ParentColumnFieldName #>, <# } #> }).ToList() 
				, new string[] { <# foreach (var kc in child.Columns) {#> "<#= kc.ChildColumnFieldName #>", <# } #> }
				, SetChildren<#= child.ChildClassFieldName #>);

			<# } #>		
			QueryResultForChildrenOnly(entities);

			<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
			{ 
				
#>Get<#= child.ChildClassName #>Reader().SetAllChildrenForExisting(entities.SelectMany(e => e.<#= child.ChildClassFieldName #>).ToList());
			<# } } #>		
		}
    }
}
		<# manager.EndBlock();
	}

	manager.Process(true);
#>